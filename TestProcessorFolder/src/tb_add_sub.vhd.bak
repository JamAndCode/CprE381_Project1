library IEEE;
use IEEE.std_logic_1164.all;

entity tb_add_sub is
generic(N : integer := 32);
end tb_add_sub;

architecture behavior of tb_add_sub is

component add_sub
generic(N : integer := 32);
port(i_A	: in std_logic_vector(N-1 downto 0);
     i_B	: in std_logic_vector(N-1 downto 0);
     S	: in std_logic;
     o_Sum	: out std_logic_vector(N-1 downto 0);
     o_Cout	: out std_logic);
end component;

signal s_A, s_B, s_Sum	: std_logic_vector(N-1 downto 0);
signal s_Cout, s_Add_Sub		: std_logic;

begin

add_sub_1 : add_sub
port map(i_A => s_A,
	 i_B => s_B,
	 o_Cout => s_Cout,
	 o_Sum => s_Sum,
	 S => s_Add_Sub);



process
begin
			--Addition Test(No overflow Test)


s_A <= x"01011101";	--simple operation with the carry
s_B <= x"00100011";
s_Add_Sub <='0';
wait for 50 ns;

s_A <= x"AAFFFFFF";	--test with several carry
s_B <= x"6A000200";
s_Add_Sub <= '0';
wait for 50 ns;

s_A <= x"FFFFFFEE";	--test the operation do nothing if adding 0
s_B <= x"00000000";
s_Add_Sub <= '0';
wait for 50 ns;

s_A <= x"FFFFFFEE";	--test the addition operation can reach its maximum
s_B <= x"00000011";
s_Add_Sub <= '0';
wait for 50 ns;
		
    			--Subtration Test

s_A <= x"AEAFBFFF";	--simple sub operation without the carry
s_B <= x"00110011";
s_Add_Sub <= '1';
wait for 50 ns;

s_A <= x"AEAFBF11";	--simple sub operation with the carry
s_B <= x"111100FF";
s_Add_Sub <= '1';
wait for 50 ns;

s_A <= x"AEAFBF11";	--test the subtraction with total 0
s_B <= x"00000000";
s_Add_Sub <= '1';
wait for 50 ns;






end process;

end behavior;